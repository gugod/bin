#!/usr/bin/env perl
use v5.18;

use Getopt::Long;

use Encode qw(encode_utf8);
use Sereal::Decoder;

my %args;
GetOptions(
    \%args,
    "i=s",
    "o=s",
    "group=s",
    "group_order_by=s",
);

$args{group} //= "user.id";
$args{group_order_by} //= "length";

my $input_dir = $args{i} or die "No input dir: -i <input_dir>";
my $output_dir = $args{o} or die "No output dir: -o <output_dir>";

sub load_sereal {
    my ($file) = @_;

    my $content = do {
        local $/ = undef;
        open my $fh, "<", $file;
        <$fh>;
    };

    my $srl_decoder = Sereal::Decoder->new;
    return $srl_decoder->decode($content);
}

sub trim_tweet_text {
    my $txt = ($_[0] =~ s/\n/\n  /grs);
    $txt =~ s/\n+\z//;
    $txt =~s /\n/\n  /gs;

    if ( length($txt) > 70 || index($txt,"\n") >= 0 ) {
        $txt .= "\n";
    }
    return $txt;
}

sub t2d {
    my ($t) = @_;
    my ($dd,$mm,$yyyy) = (localtime($t))[3,4,5];
    return sprintf('%04d-%02d-%02d', ($yyyy+1900), ($mm+1), $dd);
}

sub group_sorted_by {
    my ($sorter, $groups) = @_;
    my $sub = main->can("group_sorted_by_${sorter}") or die "Unknown sorter: $sorter";
    return $sub->($groups);
}

sub group_sorted_by_name {
    my $groups = shift;
    return sort { $a cmp $b } keys %$groups;
}

sub group_sorted_by_length {
    my $groups = shift;
    return sort { @{$groups->{$a}} <=> @{$groups->{$b}} } keys %$groups;
}

my $today = t2d(time);
my $yesterday = t2d(time - 86400);

my $f = "${input_dir}/twitter-timeline-daily-${yesterday}.srl";

unless (-f $f) {
    say "Cannot find tweets from yesterday: $f";
    exit(0);
}

my $f_users = "${input_dir}/twitter-timeline-daily-users-${today}.srl";

my $tweets = load_sereal($f);
my $users  = (-f $f_users) ? load_sereal($f_users) : {};
my %tweet_frequency;

for my $tweet (@$tweets) {
    my $user_id = $tweet->{"user.id"};
    my $user = $users->{ $user_id };
    if ($user) {
        $tweet->{"user.name"}        = $user->{name};
        $tweet->{"user.screen_name"} = "@" . $user->{screen_name};
    } else {
        $tweet->{"user.name"}        = "id:" . $user_id;
        $tweet->{"user.screen_name"} = "id:" . $user_id;
    }

    my @t = localtime($tweet->{created_at});
    $tweet->{"_time.hour"} = sprintf '%02d', $t[2];

    $tweet_frequency{user}{ $user_id }++;
}

for my $tweet (@$tweets) {
    my $user_id = $tweet->{"user.id"};
    $tweet->{"user._tweet_frequency"} = $tweet_frequency{user}{$user_id};
    $tweet->{"user._log_tweet_frequency"} = int( log($tweet_frequency{user}{$user_id}) );
    $tweet->{"user._log2_tweet_frequency"} = int( log($tweet_frequency{user}{$user_id})/log(2) );
    $tweet->{"user._log3_tweet_frequency"} = int( log($tweet_frequency{user}{$user_id})/log(3) );
}

for my $partition_field ("_time.hour", "user._log_tweet_frequency", "user._log2_tweet_frequency", "user._log3_tweet_frequency") {
    my %partition;
    for my $tweet (@$tweets) {
        my $g = $tweet->{$partition_field};
        push @{$partition{$g}}, $tweet;
    }

    for my $partition_value (keys %partition) {
        for my $group_field ("user.screen_name") {
            my %group;

            for my $tweet (@{ $partition{$partition_value} }) {
                my $g = $tweet->{$group_field};
                push @{$group{$g}}, $tweet;
            }

            my @group_names = group_sorted_by($args{"group_order_by"}, \%group);
            my $mail_body = "# $partition_field: $partition_value\n";

            for my $group_name (@group_names) {
                my $group_body = "\n## $group_name\n\n";
                for my $tweet (sort { $a->{created_at} <=> $b->{created_at} } @{$group{$group_name}}) {
                    my $txt = trim_tweet_text( $tweet->{text} );
                    $group_body .= "- $txt\n";
                }

                $mail_body .= $group_body;
            }

            $partition_value =~ s/ /_/g;
            open my $fh, ">", "${output_dir}/${yesterday}-${partition_field}-${partition_value}.md";
            print $fh encode_utf8($mail_body);
            close $fh;
        }
    }
}

