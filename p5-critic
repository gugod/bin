#!/usr/bin/env perl
use v5.26;
use strict;
use warnings;

package App::p5critic::Report {
    use Mo qw'default is required';
    has errors  => ( isa => "ArrayRef", lazy => 1, default => sub { [] });
    has notices => ( isa => "ArrayRef", lazy => 1, default => sub { [] });

    sub has_errors {
        my ($self) = @_;
        return (@{ $self->errors } > 0);
    }

    sub has_notices {
        my ($self) = @_;
        return (@{ $self->notices } > 0);
    }

    sub error {
        my ($self, $o) = @_;
        push @{$self->errors}, $o;
    }

    sub notice {
        my ($self, $o) = @_;
        push @{$self->notices}, $o;
    }

    sub print_errors {
        my ($self) = @_;
        # U+2620:  SKULL AND CROSSBONES
        say for map { $_ = "\x{2620}: $_"; utf8::encode($_); $_; } @{ $self->errors };
    }

    sub print_notices {
        my ($self) = @_;
        # U+2139: INFORMATION SOURCE
        say for map { $_ = "\x{2139}: $_"; utf8::encode($_); $_; } @{ $self->notices };
    }
}

package App::p5critic::PerlCodeCritic {
    use Mo qw'default is required';
    use PPR;
    use PPI;
    use File::Slurp qw(read_file);

    has src_file => ( required => 1, isa => "File", is => "ro", );
    has src_code => ( is => "rw", lazy => 1, default => sub { scalar read_file( $_[0]->src_file ) } );

    has reporter => (
        is => "ro",
        lazy => 1,
        default => sub { App::p5critic::Report->new() },
    );

    sub check {
        my ($self) = @_;

        for my $checker (
            "must_be_parsable",
            "should_have_no_imported_by_unused_subroutine"
        ) {
            $self->$checker;
            last if $self->reporter->has_errors;
        }
        return $self->reporter;
    }

    sub must_be_parsable {
        my $self = shift;
        # Parsable
        unless ($self->src_code =~ m{\A (?&PerlDocument) \Z $PPR::GRAMMAR }x) {
            $self->reporter->error("The code is not PPR-parsable.");
        }
    }

    sub should_have_no_imported_by_unused_subroutine {
        my $self = shift;
        # Explicity imported, but unused subroutine.

        my %imported;
        my %is_special = map { $_ => 1 } qw(use parent base);
        while ($self->{src_code} =~ m{ (?&PerlOWS) ((?&PerlUseStatement)) (?&PerlOWS) $PPR::GRAMMAR }gxo) {
            my $src = $1;
            next if $src =~ /\Ano/;
            my $ppi_doc = PPI::Document->new(\$src);

            my $expr_qw = $ppi_doc->find( sub { $_[1]->isa('PPI::Token::QuoteLike::Words'); });
            next unless $expr_qw;
            if (@$expr_qw == 1) {
                my $expr = $expr_qw->[0];
                my $el = $expr->sprevious_sibling;
                if ($el && $el->isa("PPI::Token::Word")) {
                    my $expr_str = "$expr";

                    unless ($is_special{"$el"}) {
                        # Given that both PPI and PPR parse this correctly, I don't care about what are the characters used for quoting. We can remove the characters at the position that are supposed to be quoting characters.
                        substr($expr_str, 0, 3) = "";
                        substr($expr_str, -1, 1) = "";

                        my @words = split ' ', $expr_str;
                        for my $w (@words) {
                            $imported{$w}++
                        }
                    }
                } else {
                    $self->reporter->error("Failed to grok this: $src");
                }
            } else {
                $self->reporter->error("Failed to grok this: $src");
            }
        }

        my %used;
        my $ppi_src = PPI::Document->new(\$self->{src_code});
        for my $el_word (@{ $ppi_src->find( sub { $_[1]->isa("PPI::Token::Word") }) //[]}) {
            $used{"$el_word"}++;
        }

        for my $tok (sort keys %imported) {
            unless ($used{$tok}) {
                $self->reporter->notice("Unused imports: $tok");
            }
        }
    }
};

package App::p5critic {
    use File::Slurp qw(read_file);
    use File::Next;

    sub looks_like_a_perl_src_file {
        my ($file) = @_;

        return 1 if $file =~ / \.(?: t|p[ml]|pod|comp ) $/xi;
        return 0 if $file =~ / \. /xi;

        if (open my $fh, '<', $file) {
            my $line = <$fh>;
            return 1 if $line =~ m{^#!.*perl};
        }
        return 0;
    }

    sub new {
        my ($class, $args) = @_;
        return bless { src_paths => $args }, __PACKAGE__;
    }

    sub run {
        my ($self) = @_;
        my $iter = File::Next::files( @{$self->{src_paths}} );
        while(defined( my $file = $iter->() )) {
            next unless looks_like_a_perl_src_file($file);
            my $o = App::p5critic::PerlCodeCritic->new(
                src_file => $file,
            );
            my $report = $o->check();

            if ($report->has_errors || $report->has_notices) {
                say "\n# " . $file;
                if ($report->has_errors) {
                    $report->print_errors;
                } elsif ($report->has_notices) {
                    $report->print_notices;
                }
                print "\n";
            }
        }
    }
};

my @paths = @ARGV;
@paths = (".") unless @paths;
App::p5critic->new(\@paths)->run;
