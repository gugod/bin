#!/usr/bin/env perl
use v5.18;
use strict;
use warnings;

use Sereal::Decoder;
use Sereal::Encoder;

my %args = @ARGV;
my $input_dir   = $args{'-i'} or die "No input dir -i";
my $output_dir  = $args{'-o'} or die "No output dir -o";

my $srl_decoder = Sereal::Decoder->new;

my @all_inputs = sort { $b cmp $a } glob($input_dir . "/twitter-timeline-daily-users-*.srl");
my $users = {};
for my $f (@all_inputs) {
    say $f;
    slurp_and_merge($users, $f);
}

my $output = "${output_dir}/twitter-user-merged.srl";
if (-f $output) {
    slurp_and_merge($users, $output);
}

my $srl_encoder = Sereal::Encoder->new;
open(my $fh, ">", "${output_dir}/twitter-user-merged.srl") or die $!;
print $fh $srl_encoder->encode($users);
close($fh);

unlink($_) for grep { -f $_ } @all_inputs;

exit;

sub slurp_and_merge {
    my ($users, $file) = @_;
    my $u = srl_slurp($file);
    if ($u) {
        hash_left_merge($users, $u);
    } else {
        say STDERR "Does not look like Sereal: $output";
        unlink($file);
    }
}

sub hash_left_merge {
    my ($h1, $h2) = @_;
    for (keys %$h2) {
        $h1->{$_} //= $h2->{$_};
    }
    return;
}

sub srl_slurp {
    my ($file) = @_;
    my $d = do {
        open(my $fh, "<", $file) or die $!;
        local $/ = undef;
        <$fh>;
    };
    my $u;
    my $srl_decoder = Sereal::Decoder->new;
    if ($srl_decoder->looks_like_sereal($d)) {
        $u = $srl_decoder->decode($d);
    }
    return $u;
}
