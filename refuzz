#!/usr/bin/env perl
use v5.18;
use warnings;
use JSON;
use String::Random;
use File::Slurp qw(write_file read_file);
# use POSIX ":sys_wait_h";

sub try_one {
    my ($re, $str) = @_;
    my $prog = <<"PROGRAM";
#!/usr/bin/env perl
use v5.18;
use Regexp::Debugger save_to => "/tmp/rx.json";

my \$str = "\Q$str\E";
\$str =~ /$re/;
PROGRAM

    write_file "/tmp/prog.pl", $prog;

    my $pid = fork();
    if ($pid == 0) {
        close STDERR;
        close STDOUT;
        close STDERR;
        exec $^X, "/tmp/prog.pl";
    } else {
        waitpid($pid, 0);
    }

    my $matched;
    my $steps = -1;
    open my $fh, '<', "/tmp/rx.json";
    while(<$fh>) {
        chomp;
        if (/"msg" : ".+(matched|failed).+(?:in|after) ([0-9]+) steps"/) {
            $matched = $1 eq "matched";
            $steps = $2;
            last;
        }
    }
    close($fh);

    return ($matched, $steps);
}

my $re = $ARGV[0];
my @strs = ("", "1");

push @strs, map { "1" x $_ } 2..20;

say "len\tsteps\tmatched?";
for my $str (@strs) {
    my ($matched,$steps) = try_one($re, $str);
    say length($str) . "\t" . $steps . "\t" . ($matched ? "True" : "False");
}
